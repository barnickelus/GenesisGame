<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Street-Kart – OSM live track</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
 html,body{margin:0;height:100%;overflow:hidden;background:#111;font-family:sans-serif;color:#fff}
 #hud{position:fixed;top:10px;left:12px;z-index:2;font-size:14px;text-shadow:0 0 4px #000}
</style>
</head>
<body>
<div id="hud">Loading OSM…</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.154/build/three.min.js"></script>

<script>
/* ------------------------------------------------------------
   1. Three-basics
------------------------------------------------------------ */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202028);
const camera = new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,2000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight); document.body.appendChild(renderer.domElement);
window.addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight);});
scene.add(new THREE.AmbientLight(0xffffff,.4));
const sun=new THREE.DirectionalLight(0xffffff,.8);sun.position.set(5,10,5);scene.add(sun);

/* ------------------------------------------------------------
   2. Get a *real* road from Overpass – Pick any bbox you like
      Times Sq block = 40.7588,-73.9855,40.7608,-73.9835
------------------------------------------------------------ */
const bbox = [40.7588,-73.9855,40.7608,-73.9835];        // [S,W,N,E]
const overpassURL = `https://overpass-api.de/api/interpreter?data=[out:json][timeout:25];
  way["highway"](bbox);out geom;`.replace('bbox',bbox.join(','));
fetch(overpassURL)
  .then(r=>r.json())
  .then(data => buildTrack(data.elements))
  .catch(err => {document.getElementById('hud').textContent='Overpass error';console.error(err);});

/* ------------------------------------------------------------
   3. Helpers – lat/lon ➜ flat metres (very rough Mercator)
------------------------------------------------------------ */
const R = 6378137, deg=Math.PI/180, lon0=bbox[1];
function llToXZ(lat,lon){
  const x = (lon-lon0)*deg*R*Math.cos(lat*deg);
  const z = -(lat-bbox[0])*deg*R;           // minus so N goes -Z (into screen)
  return [x,z];
}

/* ------------------------------------------------------------
   4. Turn ways into a centre-line, sample & extrude
------------------------------------------------------------ */
function buildTrack(ways){
  // Pick the longest highway in the bbox as the “race line”
  ways = ways.filter(w=>w.geometry && w.geometry.length>1);
  ways.sort((a,b)=>b.geometry.length-a.geometry.length);
  if(!ways.length){document.getElementById('hud').textContent='No roads found';return;}
  const pts = ways[0].geometry.map(g=>{const [x,z]=llToXZ(g.lat,g.lon);return new THREE.Vector3(x,0,z);});
  const curve = new THREE.CatmullRomCurve3(pts,false,'centripetal',.8);

  // Build quad-strip road
  const SAMPLE = 300, W=5;
  const pos=[]; const idx=[];
  for(let i=0;i<SAMPLE;i++){
    const p = curve.getPoint(i/(SAMPLE-1));
    const t = curve.getTangent(i/(SAMPLE-1)).normalize();
    const n = new THREE.Vector3(0,1,0).cross(t).normalize().multiplyScalar(W/2);
    const L=p.clone().add(n), Rpt=p.clone().sub(n);
    pos.push(L.x,0,L.z, Rpt.x,0,Rpt.z);
    if(i<SAMPLE-1){const o=i*2;idx.push(o,o+1,o+2, o+1,o+3,o+2);}
  }
  const g=new THREE.BufferGeometry();
  g.setAttribute('position',new THREE.Float32BufferAttribute(pos,3));
  g.setIndex(idx); g.computeVertexNormals();
  scene.add(new THREE.Mesh(g,new THREE.MeshLambertMaterial({color:0x4444ff})));

  makeKart(curve);
  document.getElementById('hud').textContent='Lap 0 – 0.0 s';
}

/* ------------------------------------------------------------
   5. Same kart / controls from earlier demo
------------------------------------------------------------ */
let kart,speed=0,lap=0,lapStart=performance.now();
function makeKart(curve){
  kart = new THREE.Mesh(new THREE.BoxGeometry(1.4,.6,2.2),
                        new THREE.MeshLambertMaterial({color:0xff5533}));
  kart.position.copy(curve.getPoint(0)); kart.position.y=.3; scene.add(kart);

  const keys={}; onkeydown=e=>keys[e.code]=true; onkeyup=e=>keys[e.code]=false;
  let last=performance.now();
  (function loop(now=performance.now()){
     requestAnimationFrame(loop);
     const dt=(now-last)/1000; last=now;
     drive(dt,keys); followCam(); renderer.render(scene,camera);
  })();
  function drive(dt,k){
    speed += ((k['ArrowUp']?20:0)+(k['ArrowDown']?-20:0))*dt;
    speed=Math.max(0,Math.min(speed,40));
    const steer=(k['ArrowLeft']?1:0)+(k['ArrowRight']?-1:0);
    kart.rotateY(THREE.MathUtils.degToRad(100*steer*dt)/(1+speed*.1));
    const dir=new THREE.Vector3(0,0,-1).applyQuaternion(kart.quaternion);
    kart.position.addScaledVector(dir,-speed*dt);

    // crude lap detection to first point
    if(kart.position.distanceTo(curve.getPoint(0))<3 && speed>5){
      const nowT=performance.now();
      if(nowT-lapStart>3000){lap++;document.getElementById('hud').textContent=`Lap ${lap} – ${((nowT-lapStart)/1000).toFixed(1)} s`;lapStart=nowT;}
    }
  }
  function followCam(){
    const off=new THREE.Vector3(0,4,8).applyQuaternion(kart.quaternion);
    camera.position.copy(kart.position).add(off);
    camera.lookAt(kart.position.clone().add(new THREE.Vector3(0,1,0)));
  }
}
</script>
</body>
</html>
