<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Street-Kart – iPad demo (OSM live)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#111;font-family:sans-serif;color:#fff;
            -webkit-user-select:none;user-select:none;touch-action:none;}
  #hud{position:fixed;top:10px;left:12px;z-index:2;font-size:15px;text-shadow:0 0 4px #000}
  .btn{position:fixed;width:64px;height:64px;background:rgba(255,255,255,.18);border-radius:12px;
       display:flex;align-items:center;justify-content:center;font-size:28px;color:#fff;z-index:3;
       box-shadow:0 0 6px rgba(0,0,0,.6);}
  /* D-pad layout (bottom-left) */
  #upBtn   {bottom:170px;left:92px;}
  #downBtn {bottom:42px; left:92px;}
  #leftBtn {bottom:106px;left:28px;}
  #rightBtn{bottom:106px;left:156px;}
</style>
</head>
<body>
<div id="hud">Loading OSM…</div>
<!-- mobile d-pad -->
<div class="btn" id="upBtn">▲</div>
<div class="btn" id="downBtn">▼</div>
<div class="btn" id="leftBtn">◀︎</div>
<div class="btn" id="rightBtn">▶︎</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.154/build/three.min.js"></script>
<script>
/* --------------------------------------------------------
   0.  Basic Three.js scene / renderer
-------------------------------------------------------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202028);
const camera = new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,2000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);
window.addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();
                                      renderer.setSize(innerWidth,innerHeight);});
scene.add(new THREE.AmbientLight(0xffffff,.4));
const sun = new THREE.DirectionalLight(0xffffff,.8); sun.position.set(5,10,5); scene.add(sun);

/* --------------------------------------------------------
   1.  Choose a map box & fetch the longest road with Overpass
-------------------------------------------------------- */
const bbox = [40.7588,-73.9855,40.7608,-73.9835];     // replace w/ any S,W,N,E lat/lon
const url = `https://overpass-api.de/api/interpreter?data=[out:json][timeout:25];
  way["highway"](bbox);out geom;`.replace('bbox',bbox.join(','));

fetch(url).then(r=>r.json()).then(json=>makeTrack(json.elements))
          .catch(e=>{document.getElementById('hud').textContent='Overpass error';console.error(e);});

/* crude flat-Earth projection good for a few city blocks */
const R=6378137, DEG=Math.PI/180, lon0=bbox[1];
function ll2xz(lat,lon){return [(lon-lon0)*DEG*R*Math.cos(lat*DEG), -(lat-bbox[0])*DEG*R];}

/* --------------------------------------------------------
   2.  Build track mesh & start the kart
-------------------------------------------------------- */
let kart,curve,speed=0,lap=0,lapStart=performance.now();
function makeTrack(ways){
  ways = ways.filter(w=>w.geometry && w.geometry.length>1)
             .sort((a,b)=>b.geometry.length-a.geometry.length);
  if(!ways.length){document.getElementById('hud').textContent='No roads in box';return;}
  const pts = ways[0].geometry.map(g=>{const [x,z]=ll2xz(g.lat,g.lon);return new THREE.Vector3(x,0,z);});
  curve = new THREE.CatmullRomCurve3(pts,false,'centripetal',.8);

  const SAMPLE=400,W=5, pos=[], idx=[];
  for(let i=0;i<SAMPLE;i++){
    const p=curve.getPoint(i/(SAMPLE-1)), t=curve.getTangent(i/(SAMPLE-1)).normalize(),
          n=new THREE.Vector3(0,1,0).cross(t).normalize().multiplyScalar(W/2),
          L=p.clone().add(n), R=p.clone().sub(n);
    pos.push(L.x,0,L.z,R.x,0,R.z);
    if(i<SAMPLE-1){const o=i*2;idx.push(o,o+1,o+2,o+1,o+3,o+2);}
  }
  const g=new THREE.BufferGeometry();
  g.setAttribute('position',new THREE.Float32BufferAttribute(pos,3));
  g.setIndex(idx); g.computeVertexNormals();
  scene.add(new THREE.Mesh(g,new THREE.MeshLambertMaterial({color:0x4444ff})));

  spawnKart();
  document.getElementById('hud').textContent='Lap 0 – 0.0 s';
}

/* --------------------------------------------------------
   3.  Kart, controls (keyboard + touch)
-------------------------------------------------------- */
const keys={};   /* unified key-state map */

function bindTouch(btn,idKey){
  ['touchstart','touchend','touchcancel','pointerdown','pointerup','pointercancel']
    .forEach(ev=>btn.addEventListener(ev,e=>{e.preventDefault(); keys[idKey]=ev.includes('start')||ev.includes('down');},
                                      {passive:false}));
}
bindTouch(document.getElementById('upBtn'),'ArrowUp');
bindTouch(document.getElementById('downBtn'),'ArrowDown');
bindTouch(document.getElementById('leftBtn'),'ArrowLeft');
bindTouch(document.getElementById('rightBtn'),'ArrowRight');

onkeydown=e=>{if(!e.repeat)keys[e.code]=true;};
onkeyup  =e=>{keys[e.code]=false;};

function spawnKart(){
  kart=new THREE.Mesh(new THREE.BoxGeometry(1.4,.6,2.2),
                      new THREE.MeshLambertMaterial({color:0xff5533}));
  kart.position.copy(curve.getPoint(0)); kart.position.y=.3; scene.add(kart);

  let last=performance.now();
  (function loop(now=performance.now()){
     requestAnimationFrame(loop);
     const dt=(now-last)/1000; last=now;
     drive(dt); followCam(); renderer.render(scene,camera);
  })();
}

function drive(dt){
  speed+=( (keys.ArrowUp?22:0) + (keys.ArrowDown?-22:0) )*dt;
  speed=Math.max(0,Math.min(speed,38));
  const steer=(keys.ArrowLeft?1:0)+(keys.ArrowRight?-1:0);
  kart.rotateY(THREE.MathUtils.degToRad(100*steer*dt)/(1+speed*.1));
  const dir=new THREE.Vector3(0,0,-1).applyQuaternion(kart.quaternion);
  kart.position.addScaledVector(dir,-speed*dt);

  if(curve && kart.position.distanceTo(curve.getPoint(0))<3 && speed>5){
    const now=performance.now();
    if(now-lapStart>3000){
      lap++; document.getElementById('hud').textContent=`Lap ${lap} – ${((now-lapStart)/1000).toFixed(1)} s`;
      lapStart=now;
    }
  }
}
function followCam(){
  const off=new THREE.Vector3(0,4,8).applyQuaternion(kart.quaternion);
  camera.position.copy(kart.position).add(off);
  camera.lookAt(kart.position.clone().add(new THREE.Vector3(0,1,0)));
}
</script>
</body>
</html>
